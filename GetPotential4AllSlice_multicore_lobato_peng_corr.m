function potential=GetPotential4AllSlice_multicore_lotabo_peng_corr(green_Ncol, green_Nrow,... 
    ele_n, absorp_n, ....仅有离子或者原子的弹性和吸收
    ele_n_i, absorp_n_i, ... %原子或原子+离子，弹性或者吸收
    series_n, series_n_i, ...  %原子排列次序
    ele_n_corr, ele_n_i_corr, corr_info, ... %如果修正peng的系数，带入的修正势场的量
    series_n_corr, series_n_i_corr, ...%修正势场，每层的原子个数
    s2, gx_green, gy_green, ...
    sigma, PARAMETER, APERTURE,paraflag);   %为了STEM计算不出错，这里只带入到HRTEM和CBED。
%paraflag 表示用lotabo还是peng的方法计算势场
potential=zeros(green_Ncol, green_Nrow, max(length(series_n), length(series_n_i)));  %每层势场都存下来

mypar=parpool;
%这里增加peng势场的修正量，先把它赋值到势场里面，程序多一个初值，相对书写上不改变原代码
%首先根据corr_info，构造相同个数的修正势场
if paraflag =='n' %如果要求计算peng的修正
    disp('Calculating the correction for Peng''s scattering factor')
    corr_info_matrix=0.*s2;%赋初值
    for i = 1:length(corr_info(:,1))  %把每种的修正势场都算出来，种类很少，所以算与元素个数相当的矩阵就好
        g2 = 4*s2;
        corr_info_matrix(:,:,i) =(corr_info(i,11)*(2+corr_info(i,12)*g2)./(1+corr_info(i,12).*g2).^2 + ...
                                  corr_info(i,13)*(2+corr_info(i,14)*g2)./(1+corr_info(i,14).*g2).^2 + ...
                                  corr_info(i,15)*(2+corr_info(i,16)*g2)./(1+corr_info(i,16).*g2).^2 + ...
                                  corr_info(i,17)*(2+corr_info(i,18)*g2)./(1+corr_info(i,18).*g2).^2 + ...
                                  corr_info(i,19)*(2+corr_info(i,20)*g2)./(1+corr_info(i,20).*g2).^2 ) -...
                                 (corr_info(i,1).*exp(-s2.*corr_info(i,2)) ...
                                 + corr_info(i,3).*exp(-s2.*corr_info(i,4)) ...
                                 + corr_info(i,5).*exp(-s2.*corr_info(i,6)) ...
                                 + corr_info(i,7).*exp(-s2.*corr_info(i,8)) ...
                                 + corr_info(i,9).*exp(-s2.*corr_info(i,10)));                           
    end  %gpu,输入这个矩阵更方便一些
    
    beg_corr1(1)=0;
    if ~isempty(series_n_corr)
        for i=1:length(series_n_corr);
            beg_corr1(i+1)=sum(series_n_corr(1:i));
        end
     end
     beg_corr2(1)=0;
     if ~isempty(series_n_i_corr)
         for i=1:length(series_n_i_corr);
              beg_corr2(i+1)=sum(series_n_i_corr(1:i));
         end
     end

     if ~isempty(series_n_corr)
         parfor i=1:length(series_n_corr);  %计算每一层的势场
             for  atom_i=beg_corr1(i)+1:sum(series_n_corr(1:i));  %把所有原子的修正势场叠加起来
                  potential(:,:,i)=potential(:,:,i)+PARAMETER*ele_n_corr(atom_i,4).*...
                          corr_info_matrix(:,:,ele_n_corr(atom_i,5)).*exp(-s2.*ele_n_corr(atom_i,3)) ...%权重*修正矩阵*debye衰减
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n_corr(atom_i,1) + gy_green*ele_n_corr(atom_i,2))); %位置信息
             end
         end
     end
   
     if ~isempty(series_n_i_corr)
         parfor i=1:length(series_n_i_corr);  %计算每一层的势场
             for  atom_i=beg_corr2(i)+1:sum(series_n_i_corr(1:i));  %把所有原子的修正势场叠加起来
                  potential(:,:,i)=potential(:,:,i)+PARAMETER*ele_n_i_corr(atom_i,4).*...
                           ( ele_n_i_corr(atom_i,5)*corr_info_matrix(:,:,ele_n_i_corr(atom_i,6)) + ele_n_i_corr(atom_i,7)*corr_info_matrix(:,:,ele_n_i_corr(atom_i,8)) ).*exp(-s2.*ele_n_i_corr(atom_i,3)) ...%权重*(离子性*修正矩阵+离子性*修正矩阵)*debye衰减
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n_i_corr(atom_i,1) + gy_green*ele_n_i_corr(atom_i,2))); %位置信息
             end
         end
     end
   
end
%-----------------------------------------------


beg1(1)=0;
if ~isempty(series_n)
    for i=1:length(series_n);
        beg1(i+1)=sum(series_n(1:i));
    end
end
beg2(1)=0;
if ~isempty(series_n_i)
    for i=1:length(series_n_i);
         beg2(i+1)=sum(series_n_i(1:i));
    end
end
%acpu=cputime;
if paraflag == 'p' || paraflag=='n'
      %先算ele_n的矩阵
      if ~isempty(series_n)
          parfor i=1:length(series_n);  %计算每一层的势场    
               i
               for atom_i=beg1(i)+1:sum(series_n(1:i));
                   %k1=sum(series_n(1:i));  %为下一层，更新计算的原子的起始序数
                   if ~isempty(ele_n)&isempty(absorp_n)
                   %仅仅计算原子或离子的弹性势场，并没有考虑分层比例;
                       potential(:,:,i)=potential(:,:,i)+PARAMETER*ele_n(atom_i,3).*...
                           ( ele_n(atom_i,4).*exp(-s2.*ele_n(atom_i,5)) ...
                           +ele_n(atom_i,6).*exp(-s2.*ele_n(atom_i,7)) ...
                           +ele_n(atom_i,8).*exp(-s2.*ele_n(atom_i,9)) ...
                           +ele_n(atom_i,10).*exp(-s2.*ele_n(atom_i,11)) ...
                           +ele_n(atom_i,12).*exp(-s2.*ele_n(atom_i,13)) ) ...
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n(atom_i,1) + gy_green*ele_n(atom_i,2)));
                   elseif ~isempty(ele_n)&~isempty(absorp_n)
                       potential(:,:,i)=potential(:,:,i)+PARAMETER*ele_n(atom_i,3)*...
                          ( ele_n(atom_i,4).*exp(-s2.*ele_n(atom_i,5)) ...
                          +ele_n(atom_i,6).*exp(-s2.*ele_n(atom_i,7)) ...
                          +ele_n(atom_i,8).*exp(-s2.*ele_n(atom_i,9)) ...
                          +ele_n(atom_i,10).*exp(-s2.*ele_n(atom_i,11)) ...
                          +ele_n(atom_i,12).*exp(-s2.*ele_n(atom_i,13))  ...
                          +sqrt(-1)*( absorp_n(atom_i,1).*exp(-s2.*absorp_n(atom_i,2)) ...
                          +absorp_n(atom_i,3).*exp(-s2.*absorp_n(atom_i,4)) ...
                          +absorp_n(atom_i,5).*exp(-s2.*absorp_n(atom_i,6)) ...
                          +absorp_n(atom_i,7).*exp(-s2.*absorp_n(atom_i,8)) ...
                          +absorp_n(atom_i,9).*exp(-s2.*absorp_n(atom_i,10)) )) ...
                          .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n(atom_i,1) + gy_green*ele_n(atom_i,2)));
                   end
               end
          end
      end
      if ~isempty(series_n_i)
          parfor i=1:length(series_n_i);  %计算每一层的势场 
                 i
             for atom_i=beg2(i)+1:sum(series_n_i(1:i));
                 %k2=sum(series_n_i(1:i));  %为下一层，更新计算的原子的起始序数
                 if ~isempty(ele_n_i) & isempty(absorp_n_i)    %考虑原子和离子性的贡献比例
                      potential(:,:,i)=potential(:,:,i)+PARAMETER* ele_n_i(atom_i,3)*(ele_n_i(atom_i,4).*...
                           ( ele_n_i(atom_i,5).*exp(-s2.*ele_n_i(atom_i,6)) ...
                           +ele_n_i(atom_i,7).*exp(-s2.*ele_n_i(atom_i,8)) ...
                           +ele_n_i(atom_i,9).*exp(-s2.*ele_n_i(atom_i,10)) ...
                           +ele_n_i(atom_i,11).*exp(-s2.*ele_n_i(atom_i,12)) ...
                           +ele_n_i(atom_i,13).*exp(-s2.*ele_n_i(atom_i,14)) ) ...
                           + ele_n_i(atom_i,15).*...
                           ( ele_n_i(atom_i,16).*exp(-s2.*ele_n_i(atom_i,17)) ...
                           +ele_n_i(atom_i,18).*exp(-s2.*ele_n_i(atom_i,19)) ...
                           +ele_n_i(atom_i,20).*exp(-s2.*ele_n_i(atom_i,21)) ...
                           +ele_n_i(atom_i,22).*exp(-s2.*ele_n_i(atom_i,23)) ...
                           +ele_n_i(atom_i,24).*exp(-s2.*ele_n_i(atom_i,25)) )) ...
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n_i(atom_i,1) + gy_green*ele_n_i(atom_i,2)));
                 elseif ~isempty(ele_n_i) & ~isempty(absorp_n_i)
                        potential(:,:,i)=potential(:,:,i)+PARAMETER* ele_n_i(atom_i,3)*(ele_n_i(atom_i,4).*...
                           ( ele_n_i(atom_i,5).*exp(-s2.*ele_n_i(atom_i,6)) ...
                           +ele_n_i(atom_i,7).*exp(-s2.*ele_n_i(atom_i,8)) ...
                           +ele_n_i(atom_i,9).*exp(-s2.*ele_n_i(atom_i,10)) ...
                           +ele_n_i(atom_i,11).*exp(-s2.*ele_n_i(atom_i,12)) ...
                           +ele_n_i(atom_i,13).*exp(-s2.*ele_n_i(atom_i,14)) ) ...
                           + ele_n_i(atom_i,15).*...
                           ( ele_n_i(atom_i,16).*exp(-s2.*ele_n_i(atom_i,17)) ...
                           +ele_n_i(atom_i,18).*exp(-s2.*ele_n_i(atom_i,19)) ...
                           +ele_n_i(atom_i,20).*exp(-s2.*ele_n_i(atom_i,21)) ...
                           +ele_n_i(atom_i,22).*exp(-s2.*ele_n_i(atom_i,23)) ...
                           +ele_n_i(atom_i,24).*exp(-s2.*ele_n_i(atom_i,25)) ) ...
                           + sqrt(-1)*( absorp_n_i(atom_i,1).*exp(-s2.*absorp_n_i(atom_i,2)) ...
                           +absorp_n_i(atom_i,3).*exp(-s2.*absorp_n_i(atom_i,4)) ...
                           +absorp_n_i(atom_i,5).*exp(-s2.*absorp_n_i(atom_i,6)) ...
                           +absorp_n_i(atom_i,7).*exp(-s2.*absorp_n_i(atom_i,8)) ...
                           +absorp_n_i(atom_i,9).*exp(-s2.*absorp_n_i(atom_i,10))))...
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n_i(atom_i,1) + gy_green*ele_n_i(atom_i,2)));
                 end
             end
          end
      end
end

if paraflag == 'l'
    g2=s2*4;
      %先算ele_n的矩阵
      if ~isempty(series_n)
          parfor i=1:length(series_n);  %计算每一层的势场    
               i
               for atom_i=beg1(i)+1:sum(series_n(1:i));
                   %k1=sum(series_n(1:i));  %为下一层，更新计算的原子的起始序数
                   if ~isempty(ele_n)&isempty(absorp_n)
                   %仅仅计算原子或离子的弹性势场，并没有考虑分层比例;
                       potential(:,:,i)=potential(:,:,i)+PARAMETER*ele_n(atom_i,3).*...
                           ( ele_n(atom_i,4).*(2+ele_n(atom_i,5)*g2)./(1+ele_n(atom_i,5).*g2).^2 ...
                           +ele_n(atom_i,6).*(2+ele_n(atom_i,7)*g2)./(1+ele_n(atom_i,7).*g2).^2 ...
                           +ele_n(atom_i,8).*(2+ele_n(atom_i,9)*g2)./(1+ele_n(atom_i,9).*g2).^2 ...
                           +ele_n(atom_i,10).*(2+ele_n(atom_i,11)*g2)./(1+ele_n(atom_i,11).*g2).^2 ...
                           +ele_n(atom_i,12).*(2+ele_n(atom_i,13)*g2)./(1+ele_n(atom_i,13).*g2).^2 ) ...
                           .*exp(-s2.*ele_n(atom_i,end))...
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n(atom_i,1) + gy_green*ele_n(atom_i,2)));
                   elseif ~isempty(ele_n)&~isempty(absorp_n)
                       potential(:,:,i)=potential(:,:,i)+PARAMETER*ele_n(atom_i,3)*...
                          ( ( ele_n(atom_i,4).*(2+ele_n(atom_i,5)*g2)./(1+ele_n(atom_i,5).*g2).^2 ...
                           +ele_n(atom_i,6).*(2+ele_n(atom_i,7)*g2)./(1+ele_n(atom_i,7).*g2).^2 ...
                           +ele_n(atom_i,8).*(2+ele_n(atom_i,9)*g2)./(1+ele_n(atom_i,9).*g2).^2 ...
                           +ele_n(atom_i,10).*(2+ele_n(atom_i,11)*g2)./(1+ele_n(atom_i,11).*g2).^2 ...
                           +ele_n(atom_i,12).*(2+ele_n(atom_i,13)*g2)./(1+ele_n(atom_i,13).*g2).^2 ) ...
                           .*exp(-s2.*ele_n(atom_i,end))  ...
                          +sqrt(-1)*( absorp_n(atom_i,1).*exp(-s2.*absorp_n(atom_i,2)) ...
                          +absorp_n(atom_i,3).*exp(-s2.*absorp_n(atom_i,4)) ...
                          +absorp_n(atom_i,5).*exp(-s2.*absorp_n(atom_i,6)) ...
                          +absorp_n(atom_i,7).*exp(-s2.*absorp_n(atom_i,8)) ...
                          +absorp_n(atom_i,9).*exp(-s2.*absorp_n(atom_i,10)) )) ...
                          .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n(atom_i,1) + gy_green*ele_n(atom_i,2)));
                   end
               end
          end
      end
      if ~isempty(series_n_i)
          parfor i=1:length(series_n_i);  %计算每一层的势场 
                 i
             for atom_i=beg2(i)+1:sum(series_n_i(1:i));
                 %k2=sum(series_n_i(1:i));  %为下一层，更新计算的原子的起始序数
                 if ~isempty(ele_n_i) & isempty(absorp_n_i)    %考虑原子和离子性的贡献比例
                      potential(:,:,i)=potential(:,:,i)+PARAMETER* ele_n_i(atom_i,3)*(ele_n_i(atom_i,4).*...
                           ( ele_n_i(atom_i,5).*(2+ele_n_i(atom_i,6)*g2)./(1+ele_n_i(atom_i,6).*g2).^2 ...
                           +ele_n_i(atom_i,7).*(2+ele_n_i(atom_i,8)*g2)./(1+ele_n_i(atom_i,8).*g2).^2 ...
                           +ele_n_i(atom_i,9).*(2+ele_n_i(atom_i,10)*g2)./(1+ele_n_i(atom_i,10).*g2).^2 ...
                           +ele_n_i(atom_i,11).*(2+ele_n_i(atom_i,12)*g2)./(1+ele_n_i(atom_i,12).*g2).^2 ...
                           +ele_n_i(atom_i,13).*(2+ele_n_i(atom_i,14)*g2)./(1+ele_n_i(atom_i,14).*g2).^2 ) ...
                           + ele_n_i(atom_i,15).*...
                           ( ele_n_i(atom_i,16).*(2+ele_n_i(atom_i,17)*g2)./(1+ele_n_i(atom_i,17).*g2).^2 ...
                           +ele_n_i(atom_i,18).*(2+ele_n_i(atom_i,19)*g2)./(1+ele_n_i(atom_i,19).*g2).^2 ...
                           +ele_n_i(atom_i,20).*(2+ele_n_i(atom_i,21)*g2)./(1+ele_n_i(atom_i,21).*g2).^2 ...
                           +ele_n_i(atom_i,22).*(2+ele_n_i(atom_i,23)*g2)./(1+ele_n_i(atom_i,23).*g2).^2 ...
                           +ele_n_i(atom_i,24).*(2+ele_n_i(atom_i,25)*g2)./(1+ele_n_i(atom_i,25).*g2).^2 )) ...
                           .*exp(-s2.*ele_n_i(atom_i,end))  ...
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n_i(atom_i,1) + gy_green*ele_n_i(atom_i,2)));
                 elseif ~isempty(ele_n_i) & ~isempty(absorp_n_i)
                        potential(:,:,i)=potential(:,:,i)+PARAMETER* ele_n_i(atom_i,3)*( (ele_n_i(atom_i,4).*...
                           ( ele_n_i(atom_i,5).*(2+ele_n_i(atom_i,6)*g2)./(1+ele_n_i(atom_i,6).*g2).^2 ...
                           +ele_n_i(atom_i,7).*(2+ele_n_i(atom_i,8)*g2)./(1+ele_n_i(atom_i,8).*g2).^2 ...
                           +ele_n_i(atom_i,9).*(2+ele_n_i(atom_i,10)*g2)./(1+ele_n_i(atom_i,10).*g2).^2 ...
                           +ele_n_i(atom_i,11).*(2+ele_n_i(atom_i,12)*g2)./(1+ele_n_i(atom_i,12).*g2).^2 ...
                           +ele_n_i(atom_i,13).*(2+ele_n_i(atom_i,14)*g2)./(1+ele_n_i(atom_i,14).*g2).^2 ) ...
                           + ele_n_i(atom_i,15).*...
                           ( ele_n_i(atom_i,16).*(2+ele_n_i(atom_i,17)*g2)./(1+ele_n_i(atom_i,17).*g2).^2 ...
                           +ele_n_i(atom_i,18).*(2+ele_n_i(atom_i,19)*g2)./(1+ele_n_i(atom_i,19).*g2).^2 ...
                           +ele_n_i(atom_i,20).*(2+ele_n_i(atom_i,21)*g2)./(1+ele_n_i(atom_i,21).*g2).^2 ...
                           +ele_n_i(atom_i,22).*(2+ele_n_i(atom_i,23)*g2)./(1+ele_n_i(atom_i,23).*g2).^2 ...
                           +ele_n_i(atom_i,24).*(2+ele_n_i(atom_i,25)*g2)./(1+ele_n_i(atom_i,25).*g2).^2 )) ...
                           .*exp(-s2.*ele_n_i(atom_i,end))  ...
                           + sqrt(-1)*( absorp_n_i(atom_i,1).*exp(-s2.*absorp_n_i(atom_i,2)) ...
                           +absorp_n_i(atom_i,3).*exp(-s2.*absorp_n_i(atom_i,4)) ...
                           +absorp_n_i(atom_i,5).*exp(-s2.*absorp_n_i(atom_i,6)) ...
                           +absorp_n_i(atom_i,7).*exp(-s2.*absorp_n_i(atom_i,8)) ...
                           +absorp_n_i(atom_i,9).*exp(-s2.*absorp_n_i(atom_i,10))) )...
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n_i(atom_i,1) + gy_green*ele_n_i(atom_i,2)));
                 end
             end
          end
      end
end

delete(mypar)
%bcpu=cputime

for i=1:max(length(series_n), length(series_n_i))   %需要乘相互作用常数
    potentialsave(:,:,i)=ifft2(ifftshift(potential(:,:,i).*APERTURE))*green_Ncol*green_Nrow;
    potential(:,:,i)=exp(sqrt(-1)*potentialsave(:,:,i)*sigma./1000);  %根据kirkland数值的关系，sigma的单位是/千伏*A
end
return;